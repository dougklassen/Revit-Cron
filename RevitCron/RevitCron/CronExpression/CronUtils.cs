using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DougKlassen.Revit.Cron
{
	/// <summary>
	/// Methods used for parsing and calculating Cron expressions
	/// </summary>
	public static class CronUtils
	{
		/// <summary>
		/// Determines whether a collection of unsorted integers is contiguous, seperated by a value of 1 from minimum to maximum
		/// </summary>
		/// <param name="set">The collection to evaluate</param>
		/// <returns>Whether the collection is contiguous</returns>
		public static Boolean IsContiguous(this IEnumerable<Int64> set)
		{
			Boolean contig = true;
			Int64[] array = set.ToArray();
			if (array.Count() < 2)
			{
				return false;	//the loop below won't execute for a set with only one value, so this must be checked first
			}

			Array.Sort(array);

			for (Int32 i = 0; i < array.Length - 1; i++)
			{
				if ((array[i] + 1) != array[i + 1])
				{
					contig = false;
				}
			}

			return contig;
		}

		/// <summary>
		/// Determines whether an array of unsorted integers is contiguous, seperated by a value of 1 from minimum to maximum
		/// </summary>
		/// <param name="set">The collection to evaluate</param>
		/// <returns>Whether the collection is contiguous</returns>
		public static Boolean IsContiguous(this UInt16[] set)
		{
			Int64[] array = Array.ConvertAll<UInt16, Int64>(set, n => (Int64)n);
			return array.IsContiguous();
		}

		/// <summary>
		/// Calculates the Cartesian products of a collection of larger intervals and smaller intervals, i.e. for a task scheduled
		/// at certain points (in minutes) during certain hours it will return a every time the task should run over
		/// the course of those hours.
		/// </summary>
		/// <param name="largeIntervals">The larger time interval</param>
		/// <param name="smallIntervals">The smaller time interval</param>
		/// <returns>The runtimes generated by combining the two intervals</returns>
		public static List<TimeSpan> GetCartesianProduct(IEnumerable<TimeSpan> largeIntervals, IEnumerable<TimeSpan> smallIntervals)
		{
			List<TimeSpan> product = new List<TimeSpan>();
			foreach (TimeSpan largeInterval in largeIntervals)
			{
				foreach (TimeSpan smallInterval in smallIntervals)
				{
					product.Add(largeInterval + smallInterval);
				}
			}
			return product;
		}

		/// <summary>
		/// Generates a Cron string representation of a series of integer values
		/// </summary>
		/// <param name="runTimes">A list of values representing run times</param>
		/// <returns>A Cron expression representing the values</returns>
		public static String GetSeriesCronString(this IList<Int64> runTimes)
		{
			StringBuilder exprBuilder = new StringBuilder(String.Empty);
			if (runTimes.IsContiguous())
			{
				exprBuilder.AppendFormat("{0}-{1}", runTimes.Min(), runTimes.Max());
			}
			else
			{
				exprBuilder.Append(runTimes[0]);
				if (runTimes.Count() > 1)
				{
					for (int i = 1; i < runTimes.Count(); i++)
					{
						exprBuilder.AppendFormat(",{0}", runTimes[i]);
					}
				}
			}
			return exprBuilder.ToString();
		}

		/// <summary>
		/// Generates a Cron string representation of a series of integer values
		/// </summary>
		/// <param name="runTimes">A list of values representing run times</param>
		/// <returns>A Cron expression representing the values</returns>
		public static String GetSeriesCronString(this UInt16[] runTimes)
		{
			IList<Int64> list = Array.ConvertAll<UInt16, Int64>(runTimes, s => (Int64)s).ToList();
			return list.GetSeriesCronString();
		}

		/// <summary>
		/// Get a TimeSpan representing the span between the beginning of the specified year and the beginning of the current month
		/// </summary>
		/// <param name="month">The month for which to calculate the TimeSpan</param>
		/// <param name="year">The year for which to calculate the TimeSpan</param>
		/// <returns>The span of time between the beginning of the current year and the beginning of the current month</returns>
		public static TimeSpan GetMonthTimeSpan(UInt16 month, UInt16 year)
		{
			var yearStart = new DateTime(year, 1, 1);
			var monthStart = new DateTime(year, month, 1);

			return monthStart.Subtract(yearStart);
		}

		/// <summary>
		/// Get a TimeSpan representing the span between the beginning of the current year and the beginning of the current month
		/// </summary>
		/// <param name="month">The month for which to calculate the TimeSpan</param>
		/// <returns>The span of time between the beginning of the specified year and the beginning of the month for the specified year</returns>
		public static TimeSpan GetMonthTimeSpan(UInt16 month)
		{
			return GetMonthTimeSpan(month, (UInt16) DateTime.Now.Year);
		}
	}
}
